# JVM相关体系详解一：内存结构

[JVM - Nyima's Blog (gitee.io)](https://nyimac.gitee.io/2020/07/03/JVM学习/#4、堆)

## 1、什么是JVM

### 1.1、定义

Java Virtual Machine，JAVA程序的**运行环境**（JAVA二进制字节码的运行环境）

### 1.2、好处

>这是Java跨平台特点实现的原因

- 一次编写，到处运行
- 自动内存管理，垃圾回收机制
- 数组下标越界检查

### 1.3、JVM JRE JDK区别

![20200608150422](D:/Download/Edge/JVM/20200608150422.png)

## 2、内存结构

### 整体架构

![image-20221103211533010](C:/Users/yangA/AppData/Roaming/Typora/typora-user-images/image-20221103211533010.png)

>注意、部分说明，具体请看对应点

方法区：方法区只是一个概念，逻辑上是堆的一部分（具体实现可以不是），对应的实现在JDK1.6中为永久代，位于堆中，其中包含StringTable(串池（运行时常量池）)，在JDK1.8中，实现变为元空间，而元空间位于直接内存（操作系统的内存而非JVM内存），StringTable单独位于堆区

程序计数器：可以看做PC寄存器

虚拟机栈：即线程栈，线程私有，线程调用的方法叫做栈帧

本地方法栈：本地方法native的栈

### 2.1、程序计数器

#### 作用

用于保存JVM中下一条所要执行的指令的地址

#### 特点

- 线程私有
  - CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码
  - 程序计数器是**每个线程**所**私有**的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令
- 不会存在内存溢出，因为只保存下一条指令的地址

### 2.2、虚拟机栈*栈大小参数

#### 定义

- 每个**线程**运行需要的内存空间，称为**虚拟机栈**，线程私有的，每个线程都有自个儿的栈
- 每个栈由多个**栈帧**组成，对应着每次调用方法时所占用的内存，对应方法的压栈出栈
- 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**，也就是栈顶方法

#### 演示

```java
public class Main {
	public static void main(String[] args) {
		method1();
	}

	private static void method1() {
		method2(1, 2);
	}

	private static int method2(int a, int b) {
		int c = a + b;
		return c;
	}
}
```

![20200608150534](D:/Download/Edge/JVM/20200608150534.png)

#### 问题辨析

- 垃圾回收是否涉及栈内存？
  - **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。
- 栈内存的分配越大越好吗？
  - 不是。因为**物理内存是一定的**，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。对应如果线程越多，所需要的程序计数器也是越多的，逻辑上PC寄存器可能不能满足。
- 方法内的局部变量是否是线程安全的？
  - 如果方法内**局部变量没有逃离方法的作用范围**，则是**线程安全**的
  - 如果如果**局部变量引用了对象**，并**逃离了方法的作用范围**，可能retrun了对象，则需要考虑线程安全问题

#### 内存溢出

**Java.lang.stackOverflowError** 栈内存溢出

溢出原因分析：

- 方法的调用深度超过栈的深度（栈帧太多）：方法递归
- 方法的局部内存需要的大小超过栈能承载的大小（栈帧太大）：new byte[1024 * 1024 * 100]

#### 线程运行诊断

CPU占用过高

- Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程
  - **top**命令，查看是哪个**进程**占用CPU过高
  - **ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号** 通过ps命令进一步查看是哪个线程占用CPU过高
  - **jstack 进程id** 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来**对比定位**，注意jstack查找出的线程id是**16进制的**，**需要转换**

### 2.3、本地方法栈

一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法

### 2.4、堆*堆大小参数

#### 定义

通过new关键字**创建的对象**都会被放在堆内存

#### 特点

- **所有线程共享**，堆内存中的对象都需要**考虑线程安全问题**
- 有垃圾回收机制

#### 堆内存溢出

**java.lang.OutofMemoryError** ：java heap space. 堆内存溢出

#### 堆内存诊断

**jps**

**jmap**

**jconsole**:可视化

**jvirsalvm**：可视化

### 2.5、方法区

![image-20221103214847207](C:/Users/yangA/AppData/Roaming/Typora/typora-user-images/image-20221103214847207.png)